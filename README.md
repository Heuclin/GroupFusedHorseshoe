

# The Bayesian group fused horseshoe prior

B. Heuclin, J. Gibaud, F. Mortier, C. Trottier, S. Tisné, M. Denis

20/05/2021

![](logo.png)

We propose the Bayesian group fused horseshoe prior implemented in a MCMC sampler (in R language) for the double selection of groups of variables and variables while taking into account the explicative variables indexation. 
This work is related to the paper: 
"Bayesian sparse group selection with indexed regressors within groups: the group fused horseshoe prior", B. Heuclin, J. Gibaud, F. Mortier, C. Trottier, S. Tisné and M. Denis (submitted).


* The `algo_group_fusion_horseshoe.R` file contains the R code of the MCMC sampler algorithm. 
* The `Application` folder contains the fruit abscission dataset `abscission.Rdata` and the R script `script_abscission.R` using to generate the application results of the paper.
* The `Simulation` folder constains the R script `script_simulation.R` using to generate the simulated results of the paper. 

### Description of the fruit abscission dataset `abscission.Rdata`:
It contains:

  * `DFD`, a 1173-vector which is the days from pollination to fruit drop of bunches (the response variable) and
  * `X_list`, a list containing 9 1173x121-matrices of measurements associated to the 9 environmental variables (Tmax, Tmin, RH, VPD, FTSW, DRD, SD, R and SR)

### Description of the R functions:
`algo_group_fusion_horseshoe.R` file contains three functions:

**The `group_fused_HS` function** is the main function allowing to run easilly different replications of the MCMC algorithm (the the `group_fused_HS_MCMC` function) with cross-validation procedure. 
The arguments of this function are:

* `y`: vector of the response variable
* `X`: the matrix of the indexing variable, if many groups are present, X is the collection of all matrix associated to each group
* `selection`: Boolean indicating if selection of variable is needed (fused) or not (fusion), default choice is TRUE
* `degree`: number indicating the degre of the difference penalty, must be >= 1, default choice is 1
* `nb_group`: number of group, default choice is 1
* `length_group`: optional, vector of the length of each group, default choice is NULL indicating that all groups have the same length `(ncol(X)/nb_group)`
* `model`: indicating is the responce is gaussian (`model='gaussian'`) or probit regression (`model='probit'`)
* `niter`: number of iteration of the MCMC chain, default is 10000
* `burnin`: number of initial iterations of the MCMC chain which should be discarded, defaults to 5000
* `thin`: save only every thin-th iteration, default is 10
* `CV`: numeric, indicating the number of folds for cross-validation, defaults to NULL indicating no cross-validation
* `id.cv`: optional, list of length 'rep' of vector of length 'n'. Each vector indicates the group indicator of the individuals for the cross-validation, defaults is NULL indicating the function affects ramdomly a fold to each individual for each repetition
* `rep`: number of replication, default is 1
* `cores`: number of cores for parallelisation, default is 1
* `gelman.plot`: boolean indicating if the gelman plot should be plotted in the case where K is upper than one, default is FALSE
* `traceplot`: boolean indicating if the traceplot should be plotted in the case where K is upper than one, default is FALSE
* `Z`: optional design matrix for a random effect
* `A`: opational covariance matrix for a random effect
* `save`: boolean indicating if the MCMC chains should me saved, default is true
* `path`: optional, path to save the MCMC chains if `save = TRUE`. If `NULL`, `path = Fused_HS` if `selection = TRUE`, `path = Fusion_HS` ortherwise
* `...`: additional arguments for the fused_horseshoe_MCMC function

It return a list containing:

* `settings`: the list of settings of the MCMC chains,
* `list_chain`: the list of the MCMC chains generated by \code{\link{fused_horseshoe_MCMC}}
* `waic_cv_folds`: vector of the waic of each fold if `CV != NULL`
* `waic`: the mean of the waic over the folds
* `rmse_cv_folds`: the vector of the RMSE of each fold if `CV != NULL` and `model = 'gaussian'`
* `rmse_cv`: the mean of the rmse_cv_folds
* `F1_score_cv_folds`: the vector of the F1_score of each fold if `CV != NULL` and `model = 'probit'`
* `F1_score_cv`: the mean of the F1_score_cv_folds
* `mcmc_list`: mcmc formating list of list_chain to achieve the elman-rubin diagnostic if K is upper than one
* `gelman.diag`: the gelman-rubin diagnostic if K is upper than one
* `estimations`: the estimations (mean over the chains of the mean within each chain) of the parameters



**The `group_fused_HS_MCMC` function** allows to run the MCMC sampler (for one chain) for the group fusion / fused horseshoe approach. 
The arguments of this function are:

* `y`: vector ofthe response variable
* `X`: the matrix of the indexing variable, if many groups are present, X is the collection of all matrix associated to each group
* `Z`: optional design matrix for a random effect
* `A`: optional covariance matrix for a random effect
* `group`:  vector of length ncol(X) indicating the number group of each variable in X
* `d`: the degree of the difference penalty
* `D`: the matrix of the finite difference operator
* `model`: c('gaussian', 'probit'), indicating is the responce is gaussian or probit regression
* `settings`: a list containing the MCMC settings:
    + `niter`: number of iterations of the MCMC chain
    + `burnin`: number of initial iterations of the MCMC chain which should be discarded
    + `thin`: save only every thin-th iteration

* `delta_ boolean`: indicating if a local parameters on each coefficient should be used, default is TRUE
* `lambda_delta_2_`: boolean indicating if a global parameters on the coefficient at the group level should be used, default is TRUE
* `tau_delta_2_`: boolean indicating if a global parameter on the coefficient  over all groups should be used, if the number of group is upper than one, default is TRUE, otherwise it is FALSE
* `omega_`: boolean indicating if a local parameters on coefficient differences should be used, default is TRUE
* `lambda_omega_2_`: boolean indicating if a global parameters on coefficient differences at the group level should be used, default is TRUE
* `tau_omega_2_`: boolean indicating if a global parameter on coefficient differences over all groups should be used, if the number of group is upper than one, default is TRUE, otherwise it is FALSE

It return a list of the MCMC samples of each parameter.


**The `plot.effect` function**  allows to plot the estimated coefficient profiles and their credible intervals
The arguments of this function are:
* `fit`: object from \code{sparse_group_fusion_horseshoe} function
* `...`: Arguments to be passed to \code{plot} function, such as graphical parameters




### Exemple on the fruit abscission dataset of oil palm trees

Load libraries
```{r}
rm(list = ls())
library(Matrix)
library(mvnfast)
library(invgamma)
library(truncnorm)
library(doParallel)
library(foreach)
library(coda)
```


```{r}
source("algo_group_fusion_horseshoe.R")
RMSE <- function(x, y) return(sqrt(mean((x-y)^2)))
```

Set the number of cores to run MCMC chains in parallel 
```{r}
cores <- 3
```

Load the fruit abscission dataset  
```{r}
load("Application/abscission.Rdata")
```

It contains:

  * `DFD`, a 1173-vector which is the days from pollination to fruit drop (the response variable) and
  * `X_list`, a list containing 9 1173x121-matrices of measurements associated to the 9 environmental variables (Tmax, Tmin, RH, VPD, FTSW, DRD, SD, R and SR)

```{r}
length(DFD)
dim(X_list[[1]])

id_g <- names(X_list); id_g
X <- do.call(cbind, X_list)
X_scale <- scale(X)
```

Set the number of replications and the number of folds for the cross-validation procedure
```{r}
rep <- 5
folds <- 5
n <- length(DFD)

# assign a fold number for each individual
id.cv <- list()
for(k in 1:rep) id.cv[[k]] <- sample(folds, n, replace = TRUE)
```

Create a folder to save MCMC chains
```{r}
system("mkdir results")
```

Fit the Bayesian group fused horseshoe approach
```{r}
system("mkdir results/fused_HS")

fit_fused_HS <- group_fused_HS(
  y=DFD, X=X_scale, selection = TRUE, degree = 1, nb_group = length(id_g),
  model = 'gaussian', niter = 15000, burnin = 5000,
  thin = 20, rep = rep, cores = cores, CV = folds,
  id.cv = id.cv, path = "results/fused_HS")
```

Plot estimated coefficient profiles
```{r}
plot.effect(fit_fused_HS, t='l', col = 4)
```



